<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D行星尘埃环</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
    </style>
    <!-- 使用Three.js官方推荐的ES模块CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // 检查WebGL支持
        if (!window.WebGLRenderingContext) {
            alert('您的浏览器不支持WebGL，请更换Chrome/Firefox/Edge等现代浏览器');
        }
        
        // 初始化场景、相机和渲染器
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        // 添加轨道控制器（正确导入方式）
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // 设置相机位置（更靠近行星）
        camera.position.set(0, 0, 3);
        
        // 添加光源
        const ambientLight = new THREE.AmbientLight(0x444455, 1.5); // 环境光
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 1.5); // 点光源
        pointLight.position.set(5, 3, 5);
        scene.add(pointLight);
        
        // 创建地球风格的行星
        function createEarthLikePlanet() {
            // 使用地球纹理贴图（模拟真实地球）
            const textureLoader = new THREE.TextureLoader();
            
            // 地球材质（蓝色为主，类似地球海洋）
            const planetMaterial = new THREE.MeshStandardMaterial({
                color: 0x2233ff,  // 基础蓝色
                roughness: 0.7,  // 适当粗糙度模拟海洋波浪
                metalness: 0.1,  // 低金属感
                emissive: 0x112244,  // 微弱自发光
                emissiveIntensity: 0.2
            });
            
            // 创建行星几何体
            const planetGeometry = new THREE.SphereGeometry(1, 64, 64);
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            scene.add(planet);
            
            return planet;
        }
        
        // 创建行星
        const planet = createEarthLikePlanet();

        // 创建类似地球云层的半透明环
        function createCloudRing() {
            const cloudGeometry = new THREE.SphereGeometry(1.02, 64, 64);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,  // 白色云层
                transparent: true,
                opacity: 0.3,     // 半透明
                side: THREE.DoubleSide
            });
            
            const cloudRing = new THREE.Mesh(cloudGeometry, cloudMaterial);
            scene.add(cloudRing);
            
            return cloudRing;
        }
        
        // 创建云层
        const cloudRing = createCloudRing();
        
        // 创建尘埃环粒子系统
        const particlesCount = 8000;
        const particlesGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particlesCount * 3);
        const particleSizes = new Float32Array(particlesCount);
        const particleColors = new Float32Array(particlesCount * 3);
        
        // 尘埃颜色（黄褐色，类似地球大气尘埃）
        const dustColor = new THREE.Color(0xd4a373);
        
        for (let i = 0; i < particlesCount; i++) {
            // 计算粒子在圆环上的位置
            const angle = Math.random() * Math.PI * 2;
            const radius = 1.6 + Math.random() * 0.4; // 尘埃环半径
            // 0到π之间的随机倾角，形成完整环面
            const inclination = Math.random() * Math.PI;
            
            // 使用球面坐标计算位置
            particlePositions[i * 3] = radius * Math.sin(inclination) * Math.cos(angle);
            particlePositions[i * 3 + 1] = radius * Math.cos(inclination);
            particlePositions[i * 3 + 2] = radius * Math.sin(inclination) * Math.sin(angle);
            
            
            // 随机粒子大小
            particleSizes[i] = Math.random() * 0.05 + 0.03;
            
            // 尘埃颜色（微小变化）
            particleColors[i * 3] = dustColor.r * (0.9 + Math.random() * 0.2);
            particleColors[i * 3 + 1] = dustColor.g * (0.9 + Math.random() * 0.2);
            particleColors[i * 3 + 2] = dustColor.b * (0.9 + Math.random() * 0.2);
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particlesGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
        
        // 尘埃粒子材质
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.01,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true,
            depthWrite: false
        });
        
        // 创建粒子系统
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);
        
        // 动画参数
        const particleSystem = {
            positions: particlePositions,
            sizes: particleSizes,
            velocities: Array.from({length: particlesCount}, () => ({
                angle: Math.random() * Math.PI * 2,
                speed: 0.003 + Math.random() * 0.005, // 速度变化
                inclination: Math.random() * Math.PI, // 0到π之间的随机倾角
                height: (Math.random() - 0.5) * 0.005 // 高度波动
            }))
        };
        
        // 行星自转参数
        let planetRotation = 0;
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            try {
                // 行星自转
                planetRotation += 0.005;
                planet.rotation.y = planetRotation;
                cloudRing.rotation.y = planetRotation * 1.1; // 云层转速略快
                
                // 更新粒子位置
                for (let i = 0; i < particlesCount; i++) {
                    const i3 = i * 3;
                    const vel = particleSystem.velocities[i];
                    
                    // 更新角度
                    vel.angle += vel.speed;
                    
                    // 计算新位置
                    const radius = 1.6 + Math.sin(planetRotation * 2 + i * 0.1) * 0.1;
                    particleSystem.positions[i3] = radius * Math.sin(vel.inclination) * Math.cos(vel.angle);
                    particleSystem.positions[i3 + 1] = radius * Math.cos(vel.inclination);
                    particleSystem.positions[i3 + 2] = radius * Math.sin(vel.inclination) * Math.sin(vel.angle);
                    
                    // 粒子大小脉动
                    particleSystem.sizes[i] = (0.03 + Math.sin(planetRotation * 4 + i) * 0.02) * 
                                            (0.9 + 0.1 * Math.sin(time * 5 + i));
                }
                
                // 更新缓冲区
                particlesGeometry.attributes.position.needsUpdate = true;
                particlesGeometry.attributes.size.needsUpdate = true;
                
                // 更新控制器
                controls.update();
                
                // 渲染场景
                renderer.render(scene, camera);
            } catch (error) {
                console.error("渲染错误:", error);
            }
        }
        
        // 窗口调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 启动动画
        const time = Date.now() * 0.001;
        animate();
    </script>
</body>
</html>